{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About GitHub repo Radek \u0158ezn\u00ed\u010dek Overview Library providing testing mechanisms to run application in memory with needed third party dependencies like Kafka, RabbitMq, NoSQL databases, SQL Technology Description Support nuget .NET8 in memory factory \u2713 Common ASP.NET in memory factory \u2713 Asp Kafka Test container with kafka and schema registry with topics creation \u2713 Kafka Elasticsearch Test container with elastic \u2713 Elasticsearch RabbitMQ Test container with rabbit supporting exchanges and routing keys creation \u2713 RabbitMq MsSQL Test container with SQL supporting init seed \u2713 Sql Redis Test container with Redis \u2713 Redis Mongo Test container with Mongo supporting init seed \u2713 Mongo Azure Blob Test container with Azure Blob \u2713 Azurite PostgreSQL Container with PostgreSQL supporting init seed and snapshot management \u2718 - MariaDB Container with MariaDB supporting init seed and snapshot management \u2718 - Azure service bus \u2718 - Release notes Version Task Info 1.0.0 Beggining of this master piece 2.0.0 Fixed namespaces 2.1.0 Added azurite - support for Azure blob 2.1.2 Fixed azurite - mea culpa 2.3.0 Fixed stuff around websocket which didnt work and fixed Configuration binding with Timespans 2.4.0 #36 Added support for RabbitMq 2.4.1 #44 Added sql backup-restore mechanism 2.4.2 #51 Added sql data obtaining mechanism + Directory.Build.props instead of common.props 2.5.0 #54 Added Blob assert + dataInfo obtaining extensions + seed support 2.6.0 #57 Added redis assert + keys/value obtaining extensions + seed support 2.7.0 #61 Removed redundant regex needs of SetAssertionRegex #62 Fixed optionality of seed for Redis and Blob 2.7.1 #65 Fixed nullable properties in SQL obtained objects #66 Fixed bool mapping #67 Added extension to obtain collection #68 Fixed blob work with spaces in names 2.7.2 Fixed SQL extensions, so they don't need to satisfy new() generic policy 2.7.3 SQL assertion and data retrieval nullable fields fix 2.7.4 Fixed custom port usage 2.7.5 Fixed custom port usage for Blob 2.7.6 Fixed SQL extension to work with NUMERIC() as decimal 2.7.7 Invariant culture in SQL object mapper 2.7.8 2.7.9 Support for entity inheritance in GetMsSqlObjectWithBaseAsync 2.7.10 Support for float in sql which is in EF as real 2.7.11 SQL Extensions Support for DateOnly, TimeOnly and Guids 2.7.12 Support for entity inheritance in GetMsSqlCollectionWithBaseAsync 2.7.13 SQL Support for DateTime as datetime2 2.7.14 .NET 9 2.7.15 SQL Server can run in Express mode 2.7.16 SQL Wait strategies 2.7.17 SQL editable w8 strategy + Container config 2.7.18 SQL wait before init script 2.7.19 SQL Error handling 2.7.20 SQL Error handling 2.7.21 ContainerConfig DelayBeforeInit for toaster agents 2.7.22 optimisation for toaster agents 2.7.23 optimisation for toaster agents 2.7.24 optimisation for toaster agents 2.7.25 optimisation for toaster agents 2.7.26 optimisation for toaster agents 2.7.27 optimisation for toaster agents 2.7.28 SQL snapshot mechanism 2.7.29 Azurite custom version support 2.7.30 AzureCLI custom version support + SkipApiVersionCheck 3.0.0 Major release - switched to .NET 10, updated dependencies (Rabbit not working tho O:) will be fixed! ) 3.0.1 3.1.0 Fixed async lifetime handling - (Rabbit still not working tho O:) will be fixed! somehow once 3.1.1 Added new HttpClient creation support + sql connection cleanup - (Rabbit still not working tho O:) will be fixed! somehow once","title":"Home"},{"location":"#about","text":"GitHub repo Radek \u0158ezn\u00ed\u010dek","title":"About"},{"location":"#overview","text":"Library providing testing mechanisms to run application in memory with needed third party dependencies like Kafka, RabbitMq, NoSQL databases, SQL Technology Description Support nuget .NET8 in memory factory \u2713 Common ASP.NET in memory factory \u2713 Asp Kafka Test container with kafka and schema registry with topics creation \u2713 Kafka Elasticsearch Test container with elastic \u2713 Elasticsearch RabbitMQ Test container with rabbit supporting exchanges and routing keys creation \u2713 RabbitMq MsSQL Test container with SQL supporting init seed \u2713 Sql Redis Test container with Redis \u2713 Redis Mongo Test container with Mongo supporting init seed \u2713 Mongo Azure Blob Test container with Azure Blob \u2713 Azurite PostgreSQL Container with PostgreSQL supporting init seed and snapshot management \u2718 - MariaDB Container with MariaDB supporting init seed and snapshot management \u2718 - Azure service bus \u2718 -","title":"Overview"},{"location":"#release-notes","text":"Version Task Info 1.0.0 Beggining of this master piece 2.0.0 Fixed namespaces 2.1.0 Added azurite - support for Azure blob 2.1.2 Fixed azurite - mea culpa 2.3.0 Fixed stuff around websocket which didnt work and fixed Configuration binding with Timespans 2.4.0 #36 Added support for RabbitMq 2.4.1 #44 Added sql backup-restore mechanism 2.4.2 #51 Added sql data obtaining mechanism + Directory.Build.props instead of common.props 2.5.0 #54 Added Blob assert + dataInfo obtaining extensions + seed support 2.6.0 #57 Added redis assert + keys/value obtaining extensions + seed support 2.7.0 #61 Removed redundant regex needs of SetAssertionRegex #62 Fixed optionality of seed for Redis and Blob 2.7.1 #65 Fixed nullable properties in SQL obtained objects #66 Fixed bool mapping #67 Added extension to obtain collection #68 Fixed blob work with spaces in names 2.7.2 Fixed SQL extensions, so they don't need to satisfy new() generic policy 2.7.3 SQL assertion and data retrieval nullable fields fix 2.7.4 Fixed custom port usage 2.7.5 Fixed custom port usage for Blob 2.7.6 Fixed SQL extension to work with NUMERIC() as decimal 2.7.7 Invariant culture in SQL object mapper 2.7.8 2.7.9 Support for entity inheritance in GetMsSqlObjectWithBaseAsync 2.7.10 Support for float in sql which is in EF as real 2.7.11 SQL Extensions Support for DateOnly, TimeOnly and Guids 2.7.12 Support for entity inheritance in GetMsSqlCollectionWithBaseAsync 2.7.13 SQL Support for DateTime as datetime2 2.7.14 .NET 9 2.7.15 SQL Server can run in Express mode 2.7.16 SQL Wait strategies 2.7.17 SQL editable w8 strategy + Container config 2.7.18 SQL wait before init script 2.7.19 SQL Error handling 2.7.20 SQL Error handling 2.7.21 ContainerConfig DelayBeforeInit for toaster agents 2.7.22 optimisation for toaster agents 2.7.23 optimisation for toaster agents 2.7.24 optimisation for toaster agents 2.7.25 optimisation for toaster agents 2.7.26 optimisation for toaster agents 2.7.27 optimisation for toaster agents 2.7.28 SQL snapshot mechanism 2.7.29 Azurite custom version support 2.7.30 AzureCLI custom version support + SkipApiVersionCheck 3.0.0 Major release - switched to .NET 10, updated dependencies (Rabbit not working tho O:) will be fixed! ) 3.0.1 3.1.0 Fixed async lifetime handling - (Rabbit still not working tho O:) will be fixed! somehow once 3.1.1 Added new HttpClient creation support + sql connection cleanup - (Rabbit still not working tho O:) will be fixed! somehow once","title":"Release notes"},{"location":"common/","text":"Common informations Docker proxy Since test runs can consume the maximum number of free pools available in the Docker registry, there is an extension on IApplicationFactory where you can set the proxy path for pulling containers. // Works for ASP aswell ApplicationFactory = new ApplicationFactoryBuilder<Program>() ... .UseProxiedImages(\"<YourDockerRegistryProxy>\") ... .Build(); Port Setting Each <Technology>Options contains a Port property, which allows you to set the desired port for running the container. Example for setting the port for SQL: .UseSql(SqlSeed, (configuration, sqlSettings) => { // SQL configuration, e.g., connection or database settings }, opts => { // Set the port where the SQL container will run opts.Port = 1200; }) Technology In this case, <Technology> is a placeholder for any specific technology (like Sql , Redis , etc.), depending on your context. Disable admin tool Each <Technology>Options contains a RunAdminTool property, which allows you to run admin tool for visualization. By default it is set to true and works only in debug mode. Example for setting the port for SQL: .UseSql(SqlSeed, (configuration, sqlSettings) => { ... }, opts => { opts.RunAdminTool = false; }) Technology In this case, <Technology> is a placeholder for any specific technology (like Sql , Redis , etc.), depending on your context.","title":"Common"},{"location":"common/#common-informations","text":"","title":"Common informations"},{"location":"common/#docker-proxy","text":"Since test runs can consume the maximum number of free pools available in the Docker registry, there is an extension on IApplicationFactory where you can set the proxy path for pulling containers. // Works for ASP aswell ApplicationFactory = new ApplicationFactoryBuilder<Program>() ... .UseProxiedImages(\"<YourDockerRegistryProxy>\") ... .Build();","title":"Docker proxy"},{"location":"common/#port-setting","text":"Each <Technology>Options contains a Port property, which allows you to set the desired port for running the container. Example for setting the port for SQL: .UseSql(SqlSeed, (configuration, sqlSettings) => { // SQL configuration, e.g., connection or database settings }, opts => { // Set the port where the SQL container will run opts.Port = 1200; }) Technology In this case, <Technology> is a placeholder for any specific technology (like Sql , Redis , etc.), depending on your context.","title":"Port Setting"},{"location":"common/#disable-admin-tool","text":"Each <Technology>Options contains a RunAdminTool property, which allows you to run admin tool for visualization. By default it is set to true and works only in debug mode. Example for setting the port for SQL: .UseSql(SqlSeed, (configuration, sqlSettings) => { ... }, opts => { opts.RunAdminTool = false; }) Technology In this case, <Technology> is a placeholder for any specific technology (like Sql , Redis , etc.), depending on your context.","title":"Disable admin tool"},{"location":"dotnet/","text":"DOTNET Usage is simple, create your application Fixture, which will be used in tests and create ApplicationFactory<TProgram> object. This fixture should inherit from ITestFixture , so you will be able to use more extensions way fluently. To add mocks use RegisterServices(Action<IServiceCollection, IConfiguration> ) method which has as parameter delegate containing IServiceProvider and IConfiguration To add configuration to provider, use UseConfiguration(Action<ConfigurationBuilder> ) method which has as parameter delegate containing ConfigurationBuilder Note that all configuration providers are removed in tests, so appSettings.*.json or any sort of .env files won't work here. You have to specify all needed configuration in this method. public class TestsFixture : ITestFixture { public IApplicationFactory ApplicationFacotry { get; } public TestsFixture() { ApplicationFacotry = new ApplicationFactoryBuilder<Program>() .RegisterServices((services, configuration) => { //add your mocks services.AddTransient(provider => SomeMockObject.Object); }) .UseConfiguration(configuration => { //Add your configuration configuration.AddObject(\"Name\", new { <impl> }); }) .Build(); ApplicationFacotry.WaitForShutdownAsync(default); } }","title":"Dotnet"},{"location":"dotnet/#dotnet","text":"Usage is simple, create your application Fixture, which will be used in tests and create ApplicationFactory<TProgram> object. This fixture should inherit from ITestFixture , so you will be able to use more extensions way fluently. To add mocks use RegisterServices(Action<IServiceCollection, IConfiguration> ) method which has as parameter delegate containing IServiceProvider and IConfiguration To add configuration to provider, use UseConfiguration(Action<ConfigurationBuilder> ) method which has as parameter delegate containing ConfigurationBuilder Note that all configuration providers are removed in tests, so appSettings.*.json or any sort of .env files won't work here. You have to specify all needed configuration in this method. public class TestsFixture : ITestFixture { public IApplicationFactory ApplicationFacotry { get; } public TestsFixture() { ApplicationFacotry = new ApplicationFactoryBuilder<Program>() .RegisterServices((services, configuration) => { //add your mocks services.AddTransient(provider => SomeMockObject.Object); }) .UseConfiguration(configuration => { //Add your configuration configuration.AddObject(\"Name\", new { <impl> }); }) .Build(); ApplicationFacotry.WaitForShutdownAsync(default); } }","title":"DOTNET"},{"location":"mocking/","text":"Mocking When dealing with asynchronous messaging, it can be challenging to determine precisely when a message will be consumed. This is where the use of CancellationTokenSource becomes essential. To manage these waiting operations, you have two options. The first is to use the UnmockAndWait extension, which allows you to wait for a mocked method's completion. However, this approach has some limitations: the mocked method can have a maximum of six arguments, and the return type must be either Task or Task<TResult> . The design is intentionally userfriendly. fixture.UnmockAndWait<IAvroHandlingService, bool, IncomingKafkaMessage, CancellationToken>( fixture.ServiceMock, src => src.EnrichAndPublishChangeEvent(It.IsAny<IncomingKafkaMessage>(), It.IsAny<CancellationToken>()), cts); In this example: The first generic parameter is the type of the service, repository, or other managing object. The second generic parameter is the return type of the method if it returns Task<TResult> . If the method returns Task , this parameter is omitted. The first argument is the mocked object. The second argument is a delegate for Moq's Returns method. The third argument is a CancellationTokenSource , used to cancel the wait for message consumption. The fourth argument, which is optional, is a TimeSpan for an additional delay, what is useful when working with databases. The remaining generic parameters specify the types of the arguments in the mocked method. Note: Avoid mocking MediatR calls unless you are familiar with its workings. Advanced Usage If the UnmockAndWait extensions do not meet your needs, you can use a more flexible mechanism that provides greater control. In this case, manually set up your mock and use the UseBaseImplementationAndCancelToken extension. This method takes a generic parameter of the service, repository, or other managing object. The first argument is a delegate that performs the action on the object, the second is the CancellationTokenSource , and the third is an optional TimeSpan to define an additional delay. fixture.SampleMongoRepoMock.Setup(s => s.InsertSampleModel(It.IsAny<SampleMongoModel>(), It.IsAny<CancellationToken>())) .Returns((SampleMongoModel model, CancellationToken ct) => { return fixture.UseBaseImplementationAndCancelToken<ISampleMongoRepository>( src => src.InsertSampleModel(model, ct), cts, TimeSpan.FromSeconds(2)); });","title":"Mocking"},{"location":"mocking/#mocking","text":"When dealing with asynchronous messaging, it can be challenging to determine precisely when a message will be consumed. This is where the use of CancellationTokenSource becomes essential. To manage these waiting operations, you have two options. The first is to use the UnmockAndWait extension, which allows you to wait for a mocked method's completion. However, this approach has some limitations: the mocked method can have a maximum of six arguments, and the return type must be either Task or Task<TResult> . The design is intentionally userfriendly. fixture.UnmockAndWait<IAvroHandlingService, bool, IncomingKafkaMessage, CancellationToken>( fixture.ServiceMock, src => src.EnrichAndPublishChangeEvent(It.IsAny<IncomingKafkaMessage>(), It.IsAny<CancellationToken>()), cts); In this example: The first generic parameter is the type of the service, repository, or other managing object. The second generic parameter is the return type of the method if it returns Task<TResult> . If the method returns Task , this parameter is omitted. The first argument is the mocked object. The second argument is a delegate for Moq's Returns method. The third argument is a CancellationTokenSource , used to cancel the wait for message consumption. The fourth argument, which is optional, is a TimeSpan for an additional delay, what is useful when working with databases. The remaining generic parameters specify the types of the arguments in the mocked method. Note: Avoid mocking MediatR calls unless you are familiar with its workings.","title":"Mocking"},{"location":"mocking/#advanced-usage","text":"If the UnmockAndWait extensions do not meet your needs, you can use a more flexible mechanism that provides greater control. In this case, manually set up your mock and use the UseBaseImplementationAndCancelToken extension. This method takes a generic parameter of the service, repository, or other managing object. The first argument is a delegate that performs the action on the object, the second is the CancellationTokenSource , and the third is an optional TimeSpan to define an additional delay. fixture.SampleMongoRepoMock.Setup(s => s.InsertSampleModel(It.IsAny<SampleMongoModel>(), It.IsAny<CancellationToken>())) .Returns((SampleMongoModel model, CancellationToken ct) => { return fixture.UseBaseImplementationAndCancelToken<ISampleMongoRepository>( src => src.InsertSampleModel(model, ct), cts, TimeSpan.FromSeconds(2)); });","title":"Advanced Usage"},{"location":"samples/","text":"Samples ASP.NET with SQL sample fixture === \"ASP Test fixture\" ```csharp \ufeffusing FluentTesting.Asp; using FluentTesting.Asp.Authentication; using FluentTesting.Asp.Extensions; using FluentTesting.Azurite; using FluentTesting.Common.Extensions; using FluentTesting.Common.Interfaces; using FluentTesting.Redis; using FluentTesting.Sql; namespace Samples.AspApp.Tests.Shared; /// <summary> /// Example of test fixture with custom options /// </summary> public class TestFixture : ITestFixture, IAsyncLifetime { public IApplicationFactory ApplicationFactory { get; } public string SqlConnectionString { get; private set; } = string.Empty; public HttpClient Client { get; } public TestFixture() { ApplicationFactory = new AspApplicationFactoryBuilder<Program>() .RegisterServices((services, configuration) => { services.RegisterAuth(); }) .UseSql(SqlSeed, (configuration, sqlSettings) => { configuration.AddConnectionString(\"Web\", sqlSettings.ConnectionString); SqlConnectionString = sqlSettings.ConnectionString; }, opts => { opts.Database = \"TestDb\"; opts.WaitStrategy = new() { IntervalSeconds = 20, RetryCount = 3, TimeoutSeconds = 120, }; opts.Port = 11434; }) .UseAzurite( (configuration, settings) => { configuration.AddConnectionString(\"BlobStorageConnection\", settings.ConnectionString); }, opts => { opts.BlobPort = 1200; opts.QueuePort = 1201; opts.TablePort = 1202; opts.Version = \"3.35.0\"; opts.AzureCliVersion = \"2.81.0\"; opts.SkipApiVersionCheck = true; opts.BlobSeed = [ new() { Name = \"photos\", Files = [ new() { Path = Path.Combine(Directory.GetCurrentDirectory(), \"Shared\", \"asd.png\"), Name = \"Some name\" } ] } ]; } ) .UseRedis( (configuration, settings) => { configuration.AddConnectionString(\"RedisConnectionString\", $\"{settings.Url}:{settings.Port}\"); }, opts => { opts.Seed = new() { { \"someKey\", \"some value :)\" }, { \"someKey2\", \"some value :)\" }, { \"someKey3\", \"some value :)\" }, { \"someKey4\", \"some value :)\" }, { \"someKey5\", \"some value :)\" }, }; }) .Build(); Client = ApplicationFactory.GetClient(); } private const string SqlSeed = @\" CREATE TABLE dbo.SomeTable( Id INT PRIMARY KEY IDENTITY(1,1), SomeInt INT NOT NULL, SomeString VARCHAR(30) NOT NULL, SomeNullableString VARCHAR(30), SomeBool bit, SomeDecimal [decimal](18, 2) NOT NULL ); CREATE TABLE dbo.SomeTableBase( Id INT PRIMARY KEY IDENTITY(1,1), SomeBaseInt INT NOT NULL, SomeBaseFloat REAL NOT NULL, SomeGuid uniqueidentifier NOT NULL, SomeDateOnly Date NOT NULL, SomeTimeOnly Time NOT NULL, SomeDateTime datetime2 Not NULL, ); INSERT INTO dbo.SomeTable(SomeInt, SomeString, SomeNullableString, SomeBool, SomeDecimal) VALUES (0, 'string', NULL, 0, 1000); INSERT INTO dbo.SomeTable(SomeInt, SomeString, SomeNullableString,SomeDecimal) VALUES (1, '0', NULL,0); INSERT INTO dbo.SomeTable(SomeInt, SomeString, SomeNullableString,SomeDecimal) VALUES (2, 'string', NULL,0); INSERT INTO dbo.SomeTable(SomeInt, SomeString, SomeNullableString,SomeDecimal) VALUES (3, '1', NULL,0); INSERT INTO dbo.SomeTableBase(SomeBaseInt, SomeBaseFloat, SomeGuid, SomeDateOnly, SomeTimeOnly, SomeDateTime) VALUES (3, 0.8, 'F0B85BE2-3F18-4E58-9976-0C2D562C7458', '2024-01-09', '10:29:00.0000000', '2024-11-03 14:30:00.0000000'); \"; public ValueTask InitializeAsync() => ApplicationFactory.InitializeAsync(); public ValueTask DisposeAsync() => ApplicationFactory.DisposeAsync(); } ```","title":"Samples"},{"location":"samples/#samples","text":"","title":"Samples"},{"location":"samples/#aspnet-with-sql-sample-fixture","text":"=== \"ASP Test fixture\" ```csharp \ufeffusing FluentTesting.Asp; using FluentTesting.Asp.Authentication; using FluentTesting.Asp.Extensions; using FluentTesting.Azurite; using FluentTesting.Common.Extensions; using FluentTesting.Common.Interfaces; using FluentTesting.Redis; using FluentTesting.Sql; namespace Samples.AspApp.Tests.Shared; /// <summary> /// Example of test fixture with custom options /// </summary> public class TestFixture : ITestFixture, IAsyncLifetime { public IApplicationFactory ApplicationFactory { get; } public string SqlConnectionString { get; private set; } = string.Empty; public HttpClient Client { get; } public TestFixture() { ApplicationFactory = new AspApplicationFactoryBuilder<Program>() .RegisterServices((services, configuration) => { services.RegisterAuth(); }) .UseSql(SqlSeed, (configuration, sqlSettings) => { configuration.AddConnectionString(\"Web\", sqlSettings.ConnectionString); SqlConnectionString = sqlSettings.ConnectionString; }, opts => { opts.Database = \"TestDb\"; opts.WaitStrategy = new() { IntervalSeconds = 20, RetryCount = 3, TimeoutSeconds = 120, }; opts.Port = 11434; }) .UseAzurite( (configuration, settings) => { configuration.AddConnectionString(\"BlobStorageConnection\", settings.ConnectionString); }, opts => { opts.BlobPort = 1200; opts.QueuePort = 1201; opts.TablePort = 1202; opts.Version = \"3.35.0\"; opts.AzureCliVersion = \"2.81.0\"; opts.SkipApiVersionCheck = true; opts.BlobSeed = [ new() { Name = \"photos\", Files = [ new() { Path = Path.Combine(Directory.GetCurrentDirectory(), \"Shared\", \"asd.png\"), Name = \"Some name\" } ] } ]; } ) .UseRedis( (configuration, settings) => { configuration.AddConnectionString(\"RedisConnectionString\", $\"{settings.Url}:{settings.Port}\"); }, opts => { opts.Seed = new() { { \"someKey\", \"some value :)\" }, { \"someKey2\", \"some value :)\" }, { \"someKey3\", \"some value :)\" }, { \"someKey4\", \"some value :)\" }, { \"someKey5\", \"some value :)\" }, }; }) .Build(); Client = ApplicationFactory.GetClient(); } private const string SqlSeed = @\" CREATE TABLE dbo.SomeTable( Id INT PRIMARY KEY IDENTITY(1,1), SomeInt INT NOT NULL, SomeString VARCHAR(30) NOT NULL, SomeNullableString VARCHAR(30), SomeBool bit, SomeDecimal [decimal](18, 2) NOT NULL ); CREATE TABLE dbo.SomeTableBase( Id INT PRIMARY KEY IDENTITY(1,1), SomeBaseInt INT NOT NULL, SomeBaseFloat REAL NOT NULL, SomeGuid uniqueidentifier NOT NULL, SomeDateOnly Date NOT NULL, SomeTimeOnly Time NOT NULL, SomeDateTime datetime2 Not NULL, ); INSERT INTO dbo.SomeTable(SomeInt, SomeString, SomeNullableString, SomeBool, SomeDecimal) VALUES (0, 'string', NULL, 0, 1000); INSERT INTO dbo.SomeTable(SomeInt, SomeString, SomeNullableString,SomeDecimal) VALUES (1, '0', NULL,0); INSERT INTO dbo.SomeTable(SomeInt, SomeString, SomeNullableString,SomeDecimal) VALUES (2, 'string', NULL,0); INSERT INTO dbo.SomeTable(SomeInt, SomeString, SomeNullableString,SomeDecimal) VALUES (3, '1', NULL,0); INSERT INTO dbo.SomeTableBase(SomeBaseInt, SomeBaseFloat, SomeGuid, SomeDateOnly, SomeTimeOnly, SomeDateTime) VALUES (3, 0.8, 'F0B85BE2-3F18-4E58-9976-0C2D562C7458', '2024-01-09', '10:29:00.0000000', '2024-11-03 14:30:00.0000000'); \"; public ValueTask InitializeAsync() => ApplicationFactory.InitializeAsync(); public ValueTask DisposeAsync() => ApplicationFactory.DisposeAsync(); } ```","title":"ASP.NET with SQL sample fixture"},{"location":"asp/asp/","text":"ASP.NET Usage is simple, create your application Fixture, which will be used in tests and create AspApplicationFactoryBuilder<TProgram> object. This fixture should inherit from ITestFixture , so you will be able to use more extensions way fluently. To add mocks use RegisterServices(Action<IServiceCollection, IConfiguration> ) method which has as parameter delegate containing IServiceProvider and IConfiguration To add configuration to provider, use UseConfiguration(Action<ConfigurationBuilder> ) method which has as parameter delegate containing ConfigurationBuilder Note that all configuration providers are removed in tests, so appSettings.*.json or any sort of .env files won't work here. You have to specify all needed configuration in this method. public class TestFixture : ITestFixture { public IApplicationFactory ApplicationFactory { get; } public HttpClient Client { get; } public TestFixture() { ApplicationFactory = new AspApplicationFactoryBuilder<Program>() .RegisterServices((services, configuration) => { //register your services etc }) .Build(); Client = ApplicationFactory.GetClient(); } }","title":"ASP"},{"location":"asp/asp/#aspnet","text":"Usage is simple, create your application Fixture, which will be used in tests and create AspApplicationFactoryBuilder<TProgram> object. This fixture should inherit from ITestFixture , so you will be able to use more extensions way fluently. To add mocks use RegisterServices(Action<IServiceCollection, IConfiguration> ) method which has as parameter delegate containing IServiceProvider and IConfiguration To add configuration to provider, use UseConfiguration(Action<ConfigurationBuilder> ) method which has as parameter delegate containing ConfigurationBuilder Note that all configuration providers are removed in tests, so appSettings.*.json or any sort of .env files won't work here. You have to specify all needed configuration in this method. public class TestFixture : ITestFixture { public IApplicationFactory ApplicationFactory { get; } public HttpClient Client { get; } public TestFixture() { ApplicationFactory = new AspApplicationFactoryBuilder<Program>() .RegisterServices((services, configuration) => { //register your services etc }) .Build(); Client = ApplicationFactory.GetClient(); } }","title":"ASP.NET"},{"location":"asp/aspExtensions/","text":"Extensions This API comes with several extensions like JWT mocking, json assertions etc Mock JWT Auth To mock jwt authentication you can simly use RegisterAuth() extensions on IServiceCollection ApplicationFactory = new AspApplicationFactoryBuilder<Program>() .RegisterServices((services, configuration) => { services.RegisterAuth(); }) .Build(); Send request with mocked JWT If you have registered mocked JWT you can use several extensions simulationg user request var res = await fixture.Client.GetAsUserAsync(\"auth\", 1); if you want to test with specific claims and roles, you will have to use JwtHelper object with GetJwt method supporting definition of roles ets await fixture.Client .AddBearerAuthHeader(JwtHelper.GetJwt(userId, claims, roles)) .GetAsync(requestUri); JSON assertation extension against file You can assert http message against json file [Fact] public async Task AnonymousEndpoint_Should_ReturnOk() { var res = await fixture.Client.GetAsync(\"\"); res.AssertStatusCode(System.Net.HttpStatusCode.OK); await fixture.AssertJsonResponseAsync(res, \"AssertJson.json\"); } Warning NOTE THAT you have to set Copy always/preserve newest on assertation file so it will appear in build folder Optionally you can specify assertion regex for getting json path if needed, but by default it should work via calling assembly ApplicationFactory = new AspApplicationFactoryBuilder<Program>() .SetAssertionRegex(@\".*Samples\\.AspApp\\.Tests[\\\\\\/]+(.*?)[\\\\\\/](?:(?![\\\\\\/]).)*$\") ... .Build();","title":"Extensions"},{"location":"asp/aspExtensions/#extensions","text":"This API comes with several extensions like JWT mocking, json assertions etc","title":"Extensions"},{"location":"asp/aspExtensions/#mock-jwt-auth","text":"To mock jwt authentication you can simly use RegisterAuth() extensions on IServiceCollection ApplicationFactory = new AspApplicationFactoryBuilder<Program>() .RegisterServices((services, configuration) => { services.RegisterAuth(); }) .Build();","title":"Mock JWT Auth"},{"location":"asp/aspExtensions/#send-request-with-mocked-jwt","text":"If you have registered mocked JWT you can use several extensions simulationg user request var res = await fixture.Client.GetAsUserAsync(\"auth\", 1); if you want to test with specific claims and roles, you will have to use JwtHelper object with GetJwt method supporting definition of roles ets await fixture.Client .AddBearerAuthHeader(JwtHelper.GetJwt(userId, claims, roles)) .GetAsync(requestUri);","title":"Send request with mocked JWT"},{"location":"asp/aspExtensions/#json-assertation-extension-against-file","text":"You can assert http message against json file [Fact] public async Task AnonymousEndpoint_Should_ReturnOk() { var res = await fixture.Client.GetAsync(\"\"); res.AssertStatusCode(System.Net.HttpStatusCode.OK); await fixture.AssertJsonResponseAsync(res, \"AssertJson.json\"); } Warning NOTE THAT you have to set Copy always/preserve newest on assertation file so it will appear in build folder Optionally you can specify assertion regex for getting json path if needed, but by default it should work via calling assembly ApplicationFactory = new AspApplicationFactoryBuilder<Program>() .SetAssertionRegex(@\".*Samples\\.AspApp\\.Tests[\\\\\\/]+(.*?)[\\\\\\/](?:(?![\\\\\\/]).)*$\") ... .Build();","title":"JSON assertation extension against file"},{"location":"blob/azureExplorer/","text":"Azure explorer To see what is inside your blob, you can use Azure explorer running on http://localhost:8100 in debug mode only. Known issues with third party image This tool looks cool and is fully configured, but there is no working support for deleting and downloading files, tested with pdf/png","title":"AzureExplorer"},{"location":"blob/azureExplorer/#azure-explorer","text":"To see what is inside your blob, you can use Azure explorer running on http://localhost:8100 in debug mode only.","title":"Azure explorer"},{"location":"blob/azureExplorer/#known-issues-with-third-party-image","text":"This tool looks cool and is fully configured, but there is no working support for deleting and downloading files, tested with pdf/png","title":"Known issues with third party image"},{"location":"blob/blob/","text":"Azure Blob To use azure blob storage use extension method on IApplicationFactoryBuilder named UseBlob with delegate containing ConfigurationBuilder and AzuriteContainerSettings . This will allow you to run elasticsearch in docker and register it within your fixture as follows. This extension lives in package: FluentTesting.Azurite .UseAzurite((configuration, settings) => { configuration.AddConnectionString(\"BlobStorageConnection\", settings.ConnectionString); }) Seed To seed data you can add AzuriteOptions filling delegate where is property named BlobSeed. Seed has structure as follows where Name is name of container (in means of BLOB) and Files has props for Path and optionally for specific file name. To set custom name set Name property, otherwise is used file name from Path .UseAzurite( (configuration, settings) => { configuration.AddConnectionString(\"BlobStorageConnection\", settings.ConnectionString); }, opts => { opts.BlobSeed = [ new() { Name = \"photos\", Files = [ new() { // Update file path to yor needs, this leads to <TestProj>/Share/asd.png file as is in Samples.AspApp.Tests Path = Path.Combine(Directory.GetCurrentDirectory(), \"Shared\", \"asd.png\") } ] } ]; } )","title":"Blob"},{"location":"blob/blob/#azure-blob","text":"To use azure blob storage use extension method on IApplicationFactoryBuilder named UseBlob with delegate containing ConfigurationBuilder and AzuriteContainerSettings . This will allow you to run elasticsearch in docker and register it within your fixture as follows. This extension lives in package: FluentTesting.Azurite .UseAzurite((configuration, settings) => { configuration.AddConnectionString(\"BlobStorageConnection\", settings.ConnectionString); })","title":"Azure Blob"},{"location":"blob/blob/#seed","text":"To seed data you can add AzuriteOptions filling delegate where is property named BlobSeed. Seed has structure as follows where Name is name of container (in means of BLOB) and Files has props for Path and optionally for specific file name. To set custom name set Name property, otherwise is used file name from Path .UseAzurite( (configuration, settings) => { configuration.AddConnectionString(\"BlobStorageConnection\", settings.ConnectionString); }, opts => { opts.BlobSeed = [ new() { Name = \"photos\", Files = [ new() { // Update file path to yor needs, this leads to <TestProj>/Share/asd.png file as is in Samples.AspApp.Tests Path = Path.Combine(Directory.GetCurrentDirectory(), \"Shared\", \"asd.png\") } ] } ]; } )","title":"Seed"},{"location":"blob/blobExtensions/","text":"Extensions Get informations To obtain some sort of informations such as file name, content length, content type, md5, created and last modified, you can use GetBlobInformationsAsync extension on ITestFixture and IApplicationFactory where arguments are container name and blob file name with extension. Blob infos model \ufeffnamespace FluentTesting.Azurite { public class BlobData { /// <summary> /// File name /// </summary> public required string Name { get; set; } /// <summary> /// Content length /// </summary> public required long ContentLength { get; set; } /// <summary> /// Content type /// </summary> public required string ContentType { get; set; } /// <summary> /// Content MD5 hash for futher assertions /// </summary> public required string ContentMd5 { get; set; } /// <summary> /// Created /// </summary> public required DateTimeOffset Created { get; set; } /// <summary> /// Last modified /// </summary> public required DateTimeOffset LastModified { get; set; } } } var blobInfos = await fixture.GetBlobInformationsAsync(\"photos\", \"asd.png\"); blobInfos.LastModified.Should().BeLessThan(TimeSpan.FromTicks(DateTimeOffset.Now.Ticks)); Note To assert MD5 hash you can use predefined Extension AssertFileResponseAgainstBlobMd5Async Assert MD5 AssertFileResponseAgainstBlobMd5Async extension on ITestFixture validates HttpResponseMessage representing FileContentResponse or any other version of stream against blob file via MD5 hash. Arguments are response, container name and file name with extension. await fixture.AssertFileResponseAgainstBlobMd5Async(res, \"photos\", \"asd.png\"); Warning If returns that blobInfo is null, you should double check that container name and file are filled correctly! Or that file really exists If your response object is more complex and contains several files, you can assert stream via AssertFileResponseAgainstBlobMd5Async extension on ITestFixture that validates Stream representing desired file against blob file via MD5 hash. Arguments are stream, container name and file name with extension. using var fileStream = await res.Content.ReadAsStreamAsync(); // Obtain specific part from multipart if needed await fixture.AssertFileResponseAgainstBlobMd5Async(fileStream, \"photos\", \"asd.png\");","title":"BlobExtensions"},{"location":"blob/blobExtensions/#extensions","text":"","title":"Extensions"},{"location":"blob/blobExtensions/#get-informations","text":"To obtain some sort of informations such as file name, content length, content type, md5, created and last modified, you can use GetBlobInformationsAsync extension on ITestFixture and IApplicationFactory where arguments are container name and blob file name with extension. Blob infos model \ufeffnamespace FluentTesting.Azurite { public class BlobData { /// <summary> /// File name /// </summary> public required string Name { get; set; } /// <summary> /// Content length /// </summary> public required long ContentLength { get; set; } /// <summary> /// Content type /// </summary> public required string ContentType { get; set; } /// <summary> /// Content MD5 hash for futher assertions /// </summary> public required string ContentMd5 { get; set; } /// <summary> /// Created /// </summary> public required DateTimeOffset Created { get; set; } /// <summary> /// Last modified /// </summary> public required DateTimeOffset LastModified { get; set; } } } var blobInfos = await fixture.GetBlobInformationsAsync(\"photos\", \"asd.png\"); blobInfos.LastModified.Should().BeLessThan(TimeSpan.FromTicks(DateTimeOffset.Now.Ticks)); Note To assert MD5 hash you can use predefined Extension AssertFileResponseAgainstBlobMd5Async","title":"Get informations"},{"location":"blob/blobExtensions/#assert-md5","text":"AssertFileResponseAgainstBlobMd5Async extension on ITestFixture validates HttpResponseMessage representing FileContentResponse or any other version of stream against blob file via MD5 hash. Arguments are response, container name and file name with extension. await fixture.AssertFileResponseAgainstBlobMd5Async(res, \"photos\", \"asd.png\"); Warning If returns that blobInfo is null, you should double check that container name and file are filled correctly! Or that file really exists If your response object is more complex and contains several files, you can assert stream via AssertFileResponseAgainstBlobMd5Async extension on ITestFixture that validates Stream representing desired file against blob file via MD5 hash. Arguments are stream, container name and file name with extension. using var fileStream = await res.Content.ReadAsStreamAsync(); // Obtain specific part from multipart if needed await fixture.AssertFileResponseAgainstBlobMd5Async(fileStream, \"photos\", \"asd.png\");","title":"Assert MD5"},{"location":"elastic/elastic/","text":"Elasticsearch To use elasticsearch use extension method on IApplicationFactoryBuilder named UseElasticSearch with delegate containing ConfigurationBuilder and ElasticSearchContainerSettings . This will allow you to run elasticsearch in docker and register it within your fixture as follows. This extension lives in package: FluentTesting.Elasticsearch .UseElasticsearch((configuration, elasticSettings) => { //Register with your specifications, this is just example configuration.AddObject(\"ElasticsearchSettings\", new { Nodes = elasticSettings.NodesUrls, }); })","title":"Elastic"},{"location":"elastic/elastic/#elasticsearch","text":"To use elasticsearch use extension method on IApplicationFactoryBuilder named UseElasticSearch with delegate containing ConfigurationBuilder and ElasticSearchContainerSettings . This will allow you to run elasticsearch in docker and register it within your fixture as follows. This extension lives in package: FluentTesting.Elasticsearch .UseElasticsearch((configuration, elasticSettings) => { //Register with your specifications, this is just example configuration.AddObject(\"ElasticsearchSettings\", new { Nodes = elasticSettings.NodesUrls, }); })","title":"Elasticsearch"},{"location":"elastic/kibana/","text":"Kibana To see what is inside your Elasticsearch, you can use Kibana running on http://localhost:9889 in debug mode only.","title":"Kibana"},{"location":"elastic/kibana/#kibana","text":"To see what is inside your Elasticsearch, you can use Kibana running on http://localhost:9889 in debug mode only.","title":"Kibana"},{"location":"faq/faq/","text":"FAQ Why can't I change the versions of the images? Different image versions have different settings. Predefined packages are carefully set to be working without any effort on user's part. If you need a different image version, consult with contributors or implement it by yourselves. Can we connect to a running instance of something, like dev DB? No, the key goal of these tests is to ensure that application and tests are running in a sandbox environment. Can I add something to this package? Yes. This project is open to extensions and improvements, and we warmly welcome contributions from those who wish to collaborate. Do I need Docker to run these tests? Yes. You need to have Docker running to run the tests. You don't have to have any specific software like Docker Desktop. This solution is working with any standard containerization tools, such as Podman, Rancher Desktop etc.","title":"FAQ"},{"location":"faq/faq/#faq","text":"Why can't I change the versions of the images? Different image versions have different settings. Predefined packages are carefully set to be working without any effort on user's part. If you need a different image version, consult with contributors or implement it by yourselves. Can we connect to a running instance of something, like dev DB? No, the key goal of these tests is to ensure that application and tests are running in a sandbox environment. Can I add something to this package? Yes. This project is open to extensions and improvements, and we warmly welcome contributions from those who wish to collaborate. Do I need Docker to run these tests? Yes. You need to have Docker running to run the tests. You don't have to have any specific software like Docker Desktop. This solution is working with any standard containerization tools, such as Podman, Rancher Desktop etc.","title":"FAQ"},{"location":"kafka/akhq/","text":"AKHQ To see what is inside your Kafka, you can use AKHQ running on http://localhost:9000 in debug mode only. Since that there is only one kafka cluster there is no need to do any extra steps, just open akhq and check your topics","title":"AKHQ"},{"location":"kafka/akhq/#akhq","text":"To see what is inside your Kafka, you can use AKHQ running on http://localhost:9000 in debug mode only. Since that there is only one kafka cluster there is no need to do any extra steps, just open akhq and check your topics","title":"AKHQ"},{"location":"kafka/kafka/","text":"TBD","title":"Kafka"},{"location":"kafka/kafka/#tbd","text":"","title":"TBD"},{"location":"mongo/mongo/","text":"Mongo Registering of MongoDb we call UseMongoDb method on IApplicationFactoryBuilder , giving seed (string of Mongo shell Javascript language), then Action<ConfigurationBuilder, MongoContainerSettings> to retrieve container's setting and optionally Action<MongoDbOptions> to set custom credentials, database and port. Default port for accessing MongoDb in this container is: 49158. public TestsFixture() { ApplicationFactory = new ApplicationFactoryBuilder<Program>() ... .UseMongo( seed, (configuration, containerSettings) => { // example how to retrieve the settings from the container and use them as will configuration.AddObject(\"MongoConfigurationOptions\", new MongoConfigurationOptions { Username = containerSettings.Username, Password = containerSettings.Password, DatabaseName = containerSettings.DatabaseName, Hosts = containerSettings.Hosts, Port = containerSettings.Port, UseTls = false }); } ) .Build(); } (Click to expand) - Optional: custom credentials and database name .UseMongo( seed, (configuration, containerSettings) => { // omitted for the sake of brevity }, // here you can set your own options, usually can be omitted when defaults are sufficient options => { options.Username = \"customlogin\"; options.Password = \"password\"; options.DatabaseName = \"TestingSamplesDatabase\"; options.Port = 40000; } ) Authorization Mongo database is created with superuser (credentials: admin // admin). For creating authorization user on specific database, you must create it using for example Seed script. Seed Seed script is executed immediately after container starts and server the purpose of initializing database. Script is accepted in Mongo shell Javascript language. Example: db = db.getSiblingDB(\"TestingSamplesDatabase\"); db.createUser({ user: \"customlogin\", pwd: \"password\", roles: [ { role: \"readWrite\", db: \"TestingSamplesDatabase\" } ] }) db.SampleCollection.insertOne({ text: \"abcd\", date: new ISODate(\"2024-08-21T13:09:12Z\") }); Optionally you can use provided SeedBuilder to generate parts (or all) of the required Seed. Using SeedBuilder to generate the script above: string seed = new SeedBuilder(\"TestingSamplesDatabase\") .CreateUser(\"customlogin\", \"password\") .InsertDocument(\"SampleCollection\", \"\"\" { text: \"abcd\", date: new ISODate(\"2024-08-21T13:09:12Z\") } \"\"\") .Build(); Usage in tests Following example shows how to assert data from Mongo using MongoDb.Driver . Implementation may differ with other packages. 1. Create Mongo client in your Fixture MongoClient = ApplicationFactory.Services.GetRequiredService<IMongoClient>(); 2. In tests' assertation retrieve data from the Mongo using client from fixture var result = await fixture.MongoClient.GetDatabase(DbName).GetCollection<SampleMongoModel>(... 3. Assert the result as needed","title":"Mongo"},{"location":"mongo/mongo/#mongo","text":"Registering of MongoDb we call UseMongoDb method on IApplicationFactoryBuilder , giving seed (string of Mongo shell Javascript language), then Action<ConfigurationBuilder, MongoContainerSettings> to retrieve container's setting and optionally Action<MongoDbOptions> to set custom credentials, database and port. Default port for accessing MongoDb in this container is: 49158. public TestsFixture() { ApplicationFactory = new ApplicationFactoryBuilder<Program>() ... .UseMongo( seed, (configuration, containerSettings) => { // example how to retrieve the settings from the container and use them as will configuration.AddObject(\"MongoConfigurationOptions\", new MongoConfigurationOptions { Username = containerSettings.Username, Password = containerSettings.Password, DatabaseName = containerSettings.DatabaseName, Hosts = containerSettings.Hosts, Port = containerSettings.Port, UseTls = false }); } ) .Build(); } (Click to expand) - Optional: custom credentials and database name .UseMongo( seed, (configuration, containerSettings) => { // omitted for the sake of brevity }, // here you can set your own options, usually can be omitted when defaults are sufficient options => { options.Username = \"customlogin\"; options.Password = \"password\"; options.DatabaseName = \"TestingSamplesDatabase\"; options.Port = 40000; } )","title":"Mongo"},{"location":"mongo/mongo/#authorization","text":"Mongo database is created with superuser (credentials: admin // admin). For creating authorization user on specific database, you must create it using for example Seed script.","title":"Authorization"},{"location":"mongo/mongo/#seed","text":"Seed script is executed immediately after container starts and server the purpose of initializing database. Script is accepted in Mongo shell Javascript language. Example: db = db.getSiblingDB(\"TestingSamplesDatabase\"); db.createUser({ user: \"customlogin\", pwd: \"password\", roles: [ { role: \"readWrite\", db: \"TestingSamplesDatabase\" } ] }) db.SampleCollection.insertOne({ text: \"abcd\", date: new ISODate(\"2024-08-21T13:09:12Z\") }); Optionally you can use provided SeedBuilder to generate parts (or all) of the required Seed. Using SeedBuilder to generate the script above: string seed = new SeedBuilder(\"TestingSamplesDatabase\") .CreateUser(\"customlogin\", \"password\") .InsertDocument(\"SampleCollection\", \"\"\" { text: \"abcd\", date: new ISODate(\"2024-08-21T13:09:12Z\") } \"\"\") .Build();","title":"Seed"},{"location":"mongo/mongo/#usage-in-tests","text":"Following example shows how to assert data from Mongo using MongoDb.Driver . Implementation may differ with other packages. 1. Create Mongo client in your Fixture MongoClient = ApplicationFactory.Services.GetRequiredService<IMongoClient>(); 2. In tests' assertation retrieve data from the Mongo using client from fixture var result = await fixture.MongoClient.GetDatabase(DbName).GetCollection<SampleMongoModel>(... 3. Assert the result as needed","title":"Usage in tests"},{"location":"mongo/mongoExpress/","text":"Mongo Express To see what is inside your Mongo, you can use Mongo Express running on http://localhost:9966 in debug mode Login Prop Val Username admin Password pass Browse this tool","title":"MongoExpress"},{"location":"mongo/mongoExpress/#mongo-express","text":"To see what is inside your Mongo, you can use Mongo Express running on http://localhost:9966 in debug mode","title":"Mongo Express"},{"location":"mongo/mongoExpress/#login","text":"Prop Val Username admin Password pass","title":"Login"},{"location":"mongo/mongoExpress/#browse-this-tool","text":"","title":"Browse this tool"},{"location":"rabbit/rabbit/","text":"Rabbit MQ To use elasticsearch use extension method on IApplicationFactoryBuilder named UseRabbitMq with delegate containing ConfigurationBuilder and RabbitMqContainerSettings . There is RabbitMQOptions delegate aswell to define exchanges, routing keys, queues and bindings. This will allow you to run RabbitMq in docker and register it within your fixture as follows. This extension lives in package: FluentTesting.RabbitMq .RegisterServices((services, configuration) => { services.AddSingleton(ConsumptionHandlerMock.Object); }) .UseRabbitMq((configuration, rabbitSettings) => { configuration.AddObject(\"RabbitConnectionOptions\", new RabbitConnectionOptions() { HostName = rabbitSettings.Host, Password = rabbitSettings.Password, UserName = rabbitSettings.UserName, }); }, opts => { opts.PublisherBindings = [new Exchange() { ExchangeName = \"test\", RoutingKeys = [\"testRoutingKey\"] }]; opts.ConsumerBindings = [ new Exchange() { ExchangeName = \"consumptionTest\", RoutingKeys = [\"RabbitMessage\"], QueueName = \"ConsumptionTestRabbitMessageQueue\" } ]; opts.DefaultQueueName = \"testQueue\"; }) .Build();","title":"RabbitMQ"},{"location":"rabbit/rabbit/#rabbit-mq","text":"To use elasticsearch use extension method on IApplicationFactoryBuilder named UseRabbitMq with delegate containing ConfigurationBuilder and RabbitMqContainerSettings . There is RabbitMQOptions delegate aswell to define exchanges, routing keys, queues and bindings. This will allow you to run RabbitMq in docker and register it within your fixture as follows. This extension lives in package: FluentTesting.RabbitMq .RegisterServices((services, configuration) => { services.AddSingleton(ConsumptionHandlerMock.Object); }) .UseRabbitMq((configuration, rabbitSettings) => { configuration.AddObject(\"RabbitConnectionOptions\", new RabbitConnectionOptions() { HostName = rabbitSettings.Host, Password = rabbitSettings.Password, UserName = rabbitSettings.UserName, }); }, opts => { opts.PublisherBindings = [new Exchange() { ExchangeName = \"test\", RoutingKeys = [\"testRoutingKey\"] }]; opts.ConsumerBindings = [ new Exchange() { ExchangeName = \"consumptionTest\", RoutingKeys = [\"RabbitMessage\"], QueueName = \"ConsumptionTestRabbitMessageQueue\" } ]; opts.DefaultQueueName = \"testQueue\"; }) .Build();","title":"Rabbit MQ"},{"location":"rabbit/rabbitManager/","text":"RabbitManager Rabbit manager runs on http://127.0.0.1:9008 | Login | Creadentials UserName PW username password","title":"RabbitMQ Manager"},{"location":"rabbit/rabbitManager/#rabbitmanager","text":"Rabbit manager runs on http://127.0.0.1:9008 |","title":"RabbitManager"},{"location":"rabbit/rabbitManager/#login","text":"|","title":"Login"},{"location":"rabbit/rabbitManager/#creadentials","text":"UserName PW username password","title":"Creadentials"},{"location":"rabbit/rabbitSamples/","text":"Samples Fixture using FluentTesting.Common; using FluentTesting.Common.Extensions; using FluentTesting.Common.Interfaces; using FluentTesting.RabbitMq; using FluentTesting.RabbitMq.Options; using Microsoft.Extensions.DependencyInjection; using Moq; using Samples.Worker.RabbitMq.ConsumptionHandlingServices; namespace Samples.Worker.RabbitMq.Tests.Shared; /// <summary> /// Example of test fixture with custom options /// </summary> public class TestFixture : ITestFixture { public IApplicationFactory ApplicationFactory { get; } public readonly Mock<IConsumptionHandler> ConsumptionHandlerMock = new(); public TestFixture() { ApplicationFactory = new ApplicationFactoryBuilder<Program>() .RegisterServices((services, configuration) => { services.AddSingleton(ConsumptionHandlerMock.Object); }) .UseRabbitMq((configuration, rabbitSettings) => { configuration.AddObject(\"RabbitConnectionOptions\", new RabbitConnectionOptions() { HostName = rabbitSettings.Host, Password = rabbitSettings.Password, UserName = rabbitSettings.UserName, }); }, opts => { opts.PublisherBindings = [new Exchange() { ExchangeName = \"test\", RoutingKeys = [\"testRoutingKey\"] }]; opts.ConsumerBindings = [ new Exchange() { ExchangeName = \"consumptionTest\", RoutingKeys = [\"RabbitMessage\"], QueueName = \"ConsumptionTestRabbitMessageQueue\" } ]; opts.DefaultQueueName = \"testQueue\"; }) .Build(); } } Publishing on app run in worker service using Microsoft.Extensions.Options; using RabbitMQ.Client; using System.Text; namespace Samples.Worker.RabbitMq { public class RabbitPublishingWorker(IOptions<RabbitConnectionOptions> opts) : BackgroundService { private readonly RabbitConnectionOptions rabbitOpts = opts.Value; protected override async Task ExecuteAsync(CancellationToken stoppingToken) { var factory = new ConnectionFactory { HostName = rabbitOpts.HostName, UserName = rabbitOpts.UserName, Password = rabbitOpts.Password, }; using var connection = await factory.CreateConnectionAsync(stoppingToken); using var channel = await connection.CreateChannelAsync(null, stoppingToken); byte[] messageBodyBytes = Encoding.UTF8.GetBytes(\"Hello, world!\"); await channel.BasicPublishAsync(\"test\", \"testRoutingKey\", true, new BasicProperties(), messageBodyBytes, stoppingToken); await channel.CloseAsync(cancellationToken: stoppingToken); await connection.CloseAsync(cancellationToken: stoppingToken); } } } Test - consumming message from rabbit to assert that it was published sucessfully using FluentAssertions; using FluentTesting.Common.Extensions; using FluentTesting.RabbitMq.Extensions; using Samples.Worker.RabbitMq.Tests.Shared; namespace Samples.Worker.RabbitMq.Tests { [Collection(\"RabbitMqFixture\")] public class RabbitPublisherTests(TestFixture fixture) { [Fact] public async Task PublishFromApp_ShouldWork() { var cts = fixture.GetCtsWithTimeoutInSeconds(); await Task.Delay(1000); var consumed = await fixture.ApplicationFactory.ConsumeRabbitMqMessage(cts.Token); consumed.Should().NotBeNull(); consumed?.Payload.Should().Be(\"Hello, world!\"); } } } Test - publishing message to RabbitMQ which is sucessfully managed by application \ufeffusing FluentAssertions; using FluentTesting.Common.Extensions; using FluentTesting.RabbitMq.Extensions; using Moq; using Samples.Worker.RabbitMq.ConsumptionHandlingServices; using Samples.Worker.RabbitMq.Contracts; using Samples.Worker.RabbitMq.Tests.Shared; namespace Samples.Worker.RabbitMq.Tests { [Collection(\"RabbitMqFixture\")] public class RabbitConsumerTests(TestFixture fixture) { [Fact] public async Task ObtainingMessages_Should_Work() { var contract = new RabbitMessage() { BirthDate = DateTime.Now, Email = \"coconut@coco.com\", SurName = \"Testschenko\", Name = \"Testicss\" }; var cts = fixture.GetCtsWithTimeoutInSeconds(60); // pseudo unmocking process to create callback to stop waiting for consumption, cause message has been consumed fixture.UnmockAndWait<IConsumptionHandler, bool, RabbitMessage, CancellationToken>( fixture.ConsumptionHandlerMock, src => src.HandleMessageAsync(It.IsAny<RabbitMessage>(), It.IsAny<CancellationToken>()), cts); await fixture.ApplicationFactory.PublishJsonToRabbitAndWaitForConsumption(\"consumptionTest\", \"RabbitMessage\", contract, cts); // This should be asserted against db or handler should create new notification etc // This static object is just here for test purposes where i don't want to include db or smth // but it is filled in handler where message is handled StaticRabbitHandlerState.RabbitMessage.BirthDate.Should().Be(contract.BirthDate); StaticRabbitHandlerState.RabbitMessage.Email.Should().Be(contract.Email); StaticRabbitHandlerState.RabbitMessage.SurName.Should().Be(contract.SurName); StaticRabbitHandlerState.RabbitMessage.Name.Should().Be(contract.Name); } } }","title":"Samples"},{"location":"rabbit/rabbitSamples/#samples","text":"Fixture using FluentTesting.Common; using FluentTesting.Common.Extensions; using FluentTesting.Common.Interfaces; using FluentTesting.RabbitMq; using FluentTesting.RabbitMq.Options; using Microsoft.Extensions.DependencyInjection; using Moq; using Samples.Worker.RabbitMq.ConsumptionHandlingServices; namespace Samples.Worker.RabbitMq.Tests.Shared; /// <summary> /// Example of test fixture with custom options /// </summary> public class TestFixture : ITestFixture { public IApplicationFactory ApplicationFactory { get; } public readonly Mock<IConsumptionHandler> ConsumptionHandlerMock = new(); public TestFixture() { ApplicationFactory = new ApplicationFactoryBuilder<Program>() .RegisterServices((services, configuration) => { services.AddSingleton(ConsumptionHandlerMock.Object); }) .UseRabbitMq((configuration, rabbitSettings) => { configuration.AddObject(\"RabbitConnectionOptions\", new RabbitConnectionOptions() { HostName = rabbitSettings.Host, Password = rabbitSettings.Password, UserName = rabbitSettings.UserName, }); }, opts => { opts.PublisherBindings = [new Exchange() { ExchangeName = \"test\", RoutingKeys = [\"testRoutingKey\"] }]; opts.ConsumerBindings = [ new Exchange() { ExchangeName = \"consumptionTest\", RoutingKeys = [\"RabbitMessage\"], QueueName = \"ConsumptionTestRabbitMessageQueue\" } ]; opts.DefaultQueueName = \"testQueue\"; }) .Build(); } } Publishing on app run in worker service using Microsoft.Extensions.Options; using RabbitMQ.Client; using System.Text; namespace Samples.Worker.RabbitMq { public class RabbitPublishingWorker(IOptions<RabbitConnectionOptions> opts) : BackgroundService { private readonly RabbitConnectionOptions rabbitOpts = opts.Value; protected override async Task ExecuteAsync(CancellationToken stoppingToken) { var factory = new ConnectionFactory { HostName = rabbitOpts.HostName, UserName = rabbitOpts.UserName, Password = rabbitOpts.Password, }; using var connection = await factory.CreateConnectionAsync(stoppingToken); using var channel = await connection.CreateChannelAsync(null, stoppingToken); byte[] messageBodyBytes = Encoding.UTF8.GetBytes(\"Hello, world!\"); await channel.BasicPublishAsync(\"test\", \"testRoutingKey\", true, new BasicProperties(), messageBodyBytes, stoppingToken); await channel.CloseAsync(cancellationToken: stoppingToken); await connection.CloseAsync(cancellationToken: stoppingToken); } } } Test - consumming message from rabbit to assert that it was published sucessfully using FluentAssertions; using FluentTesting.Common.Extensions; using FluentTesting.RabbitMq.Extensions; using Samples.Worker.RabbitMq.Tests.Shared; namespace Samples.Worker.RabbitMq.Tests { [Collection(\"RabbitMqFixture\")] public class RabbitPublisherTests(TestFixture fixture) { [Fact] public async Task PublishFromApp_ShouldWork() { var cts = fixture.GetCtsWithTimeoutInSeconds(); await Task.Delay(1000); var consumed = await fixture.ApplicationFactory.ConsumeRabbitMqMessage(cts.Token); consumed.Should().NotBeNull(); consumed?.Payload.Should().Be(\"Hello, world!\"); } } } Test - publishing message to RabbitMQ which is sucessfully managed by application \ufeffusing FluentAssertions; using FluentTesting.Common.Extensions; using FluentTesting.RabbitMq.Extensions; using Moq; using Samples.Worker.RabbitMq.ConsumptionHandlingServices; using Samples.Worker.RabbitMq.Contracts; using Samples.Worker.RabbitMq.Tests.Shared; namespace Samples.Worker.RabbitMq.Tests { [Collection(\"RabbitMqFixture\")] public class RabbitConsumerTests(TestFixture fixture) { [Fact] public async Task ObtainingMessages_Should_Work() { var contract = new RabbitMessage() { BirthDate = DateTime.Now, Email = \"coconut@coco.com\", SurName = \"Testschenko\", Name = \"Testicss\" }; var cts = fixture.GetCtsWithTimeoutInSeconds(60); // pseudo unmocking process to create callback to stop waiting for consumption, cause message has been consumed fixture.UnmockAndWait<IConsumptionHandler, bool, RabbitMessage, CancellationToken>( fixture.ConsumptionHandlerMock, src => src.HandleMessageAsync(It.IsAny<RabbitMessage>(), It.IsAny<CancellationToken>()), cts); await fixture.ApplicationFactory.PublishJsonToRabbitAndWaitForConsumption(\"consumptionTest\", \"RabbitMessage\", contract, cts); // This should be asserted against db or handler should create new notification etc // This static object is just here for test purposes where i don't want to include db or smth // but it is filled in handler where message is handled StaticRabbitHandlerState.RabbitMessage.BirthDate.Should().Be(contract.BirthDate); StaticRabbitHandlerState.RabbitMessage.Email.Should().Be(contract.Email); StaticRabbitHandlerState.RabbitMessage.SurName.Should().Be(contract.SurName); StaticRabbitHandlerState.RabbitMessage.Name.Should().Be(contract.Name); } } }","title":"Samples"},{"location":"redis/redis/","text":"Redis Registering of Redis we call UseRedis method on IApplicationFactoryBuilder , then Action<ConfigurationBuilder, RedisContainerSettings> to retrieve container's setting and optionally Action<RedisOptions> to set custom port. Default port for accessing Redis in this container is: 6001. public TestsFixture() { ApplicationFactory = new ApplicationFactoryBuilder<Program>() ... .UseRedis( (configuration, containerSettings) => { // your setting with usage of containerSettings } ) .Build(); } (Click to expand) - Optional: custom port .UseRedis( (configuration, containerSettings) => { // omitted for the sake of brevity }, // here you can set your own options, usually can be omitted when defaults are sufficient options => { options.Port = 6969; } ) Seed To register with seed fill Seed prop of type Dictionary<string, string> in options delegate .UseRedis( (configuration, settings) => { configuration.AddConnectionString(\"RedisConnectionString\", $\"{settings.Url}:{settings.Port}\"); }, opts => { opts.Seed = new() { { \"someKey\", \"some value :)\" } }; })","title":"Redis"},{"location":"redis/redis/#redis","text":"Registering of Redis we call UseRedis method on IApplicationFactoryBuilder , then Action<ConfigurationBuilder, RedisContainerSettings> to retrieve container's setting and optionally Action<RedisOptions> to set custom port. Default port for accessing Redis in this container is: 6001. public TestsFixture() { ApplicationFactory = new ApplicationFactoryBuilder<Program>() ... .UseRedis( (configuration, containerSettings) => { // your setting with usage of containerSettings } ) .Build(); } (Click to expand) - Optional: custom port .UseRedis( (configuration, containerSettings) => { // omitted for the sake of brevity }, // here you can set your own options, usually can be omitted when defaults are sufficient options => { options.Port = 6969; } )","title":"Redis"},{"location":"redis/redis/#seed","text":"To register with seed fill Seed prop of type Dictionary<string, string> in options delegate .UseRedis( (configuration, settings) => { configuration.AddConnectionString(\"RedisConnectionString\", $\"{settings.Url}:{settings.Port}\"); }, opts => { opts.Seed = new() { { \"someKey\", \"some value :)\" } }; })","title":"Seed"},{"location":"redis/redisExtensions/","text":"Extensions GetRedisKeysAsync To obtain all Redis keys, you can use the GetRedisKeysAsync extension on ITestFixture and IApplicationFactory . This method accepts an optional pattern argument to filter keys by pattern. var allKeys = await fixture.GetRedisKeysAsync(); allKeys.Should().NotBeEmpty(); allKeys.Length.Should().Be(5); GetRedisEntryValueAsync To retrieve the value of a specific Redis entry for further assertions, you can use the GetRedisEntryValueAsync extension on ITestFixture and IApplicationFactory , passing the key of the entry you want to access. var val = await fixture.GetRedisEntryValueAsync(\"someKey\"); val.Should().Be(\"some new value\"); AssertRedisValueAsync If you don't want to manually fetch the value and assert it, you can use the AssertRedisValueAsync extension on ITestFixture and IApplicationFactory . It takes the key and the expected value (represented as a string) as arguments. If you're using some form of compression or encoding, you will need to handle that separately. await fixture.AssertRedisValueAsync(\"someKey\", \"string representation of desired value\");","title":"Extensions"},{"location":"redis/redisExtensions/#extensions","text":"","title":"Extensions"},{"location":"redis/redisExtensions/#getrediskeysasync","text":"To obtain all Redis keys, you can use the GetRedisKeysAsync extension on ITestFixture and IApplicationFactory . This method accepts an optional pattern argument to filter keys by pattern. var allKeys = await fixture.GetRedisKeysAsync(); allKeys.Should().NotBeEmpty(); allKeys.Length.Should().Be(5);","title":"GetRedisKeysAsync"},{"location":"redis/redisExtensions/#getredisentryvalueasync","text":"To retrieve the value of a specific Redis entry for further assertions, you can use the GetRedisEntryValueAsync extension on ITestFixture and IApplicationFactory , passing the key of the entry you want to access. var val = await fixture.GetRedisEntryValueAsync(\"someKey\"); val.Should().Be(\"some new value\");","title":"GetRedisEntryValueAsync"},{"location":"redis/redisExtensions/#assertredisvalueasync","text":"If you don't want to manually fetch the value and assert it, you can use the AssertRedisValueAsync extension on ITestFixture and IApplicationFactory . It takes the key and the expected value (represented as a string) as arguments. If you're using some form of compression or encoding, you will need to handle that separately. await fixture.AssertRedisValueAsync(\"someKey\", \"string representation of desired value\");","title":"AssertRedisValueAsync"},{"location":"redis/redisInsight/","text":"RedisInsight To see what is inside your Redis, you can use RedisInsight running on http://localhost:9071 in debug mode !! Container has mount, but for first run you will have to setup this tool as described bellow !! Confirm EUAL Add DB Connect","title":"RedisInsight"},{"location":"redis/redisInsight/#redisinsight","text":"To see what is inside your Redis, you can use RedisInsight running on http://localhost:9071 in debug mode","title":"RedisInsight"},{"location":"redis/redisInsight/#container-has-mount-but-for-first-run-you-will-have-to-setup-this-tool-as-described-bellow","text":"Confirm EUAL Add DB Connect","title":"!! Container has mount, but for first run you will have to setup this tool as described bellow !!"},{"location":"sql/adminer/","text":"Adminer To see what is inside your SQL project, you can use Adminer running on http://localhost:8080 in debug mode only. Login Prop Val System MS SQL (beta) Server mssql UserName sa Password Strong(!)Password Database master Select table Click on the table you want to browse. Select from table","title":"Adminer"},{"location":"sql/adminer/#adminer","text":"To see what is inside your SQL project, you can use Adminer running on http://localhost:8080 in debug mode only.","title":"Adminer"},{"location":"sql/adminer/#login","text":"Prop Val System MS SQL (beta) Server mssql UserName sa Password Strong(!)Password Database master","title":"Login"},{"location":"sql/adminer/#select-table","text":"Click on the table you want to browse.","title":"Select table"},{"location":"sql/adminer/#select-from-table","text":"","title":"Select from table"},{"location":"sql/extensions/","text":"Extensions Backup and Restore On ITestsFixture and IApplicationFactory is extension BackupMsSqlDatabaseAsync which creates backup of whole database. To restore state, use RestoreMsSqlDatabasesAsync . Do not use master To make this whole work, ensure that you are not using master as db. This can be achieved by defining database name in UseSql settings as shown bellow: .UseSql(SqlSeed, (configuration, sqlSettings) => { configuration.AddConnectionString(\"Web\", sqlSettings.ConnectionString); }, opts => { opts.Database = \"TestDb\"; //specify name, default is master }) [Fact] public async Task SomeUpdatingOrCreatingtestScenario() { //Create backup await fixture.BackupMsSqlDatabasesAsync(); var res = await fixture.Client.PutAsync(\"sql\", someObject); res.AssertStatusCode(System.Net.HttpStatusCode.OK); //Restore data await fixture.RestoreMsSqlDatabasesAsync(); } Obtain data from sql for futher use To Get data there are extension on ITestsFixture and IApplicationFactory named GetMsSqlObjectAsync and GetRawMsSqlObjectAsync or for collection you can use GetMsSqlCollectionAsync GetMsSqlObjectAsync This one is trying to map data for you from sql response - for mapping purposes is used JSON, so you should reflect naming etc or use native .NET JSON attributes to achieve so. var obj = await fixture.GetMsSqlObjectAsync<SomeTable, int>(\"SomeTable\", 1, \"Id\"); obj?.SomeString.Should().Be(\"MyString\"); No enumerables Do not try to obtain collection of data with this, since this method contains TOP(1) and even will throw exception if object is assignable to IEnumerable GetRawMsSqlObjectAsync Some error may occure in serialization proces, so there is even GetRawMsSqlObjectAsync which returns raw data Raw string This extension returns response from SQL server running inside container, so it is just string which needs some work, but as was foretold, some problems in serialization may occure, so to not let you without this functionality this one comes to play var data = await fixture.GetRawMsSqlObjectAsync(\"SomeTable\", 1, \"Id\"); Example of string data representation returned from container Id SomeInt SomeString ----------- ----------- ------------------------------ 1 0 kokos (1 rows affected) GetMsSqlCollectionAsync This one is trying to map collection of data for you from sql response - for mapping purposes is used JSON, so you should reflect naming etc or use native .NET JSON attributes to achieve so. var collectionOfAll = await fixture.GetMsSqlCollectionAsync<SomeTable>(\"SomeTable\"); collectionOfAll.Should().HaveCount(4);","title":"Extensions"},{"location":"sql/extensions/#extensions","text":"","title":"Extensions"},{"location":"sql/extensions/#backup-and-restore","text":"On ITestsFixture and IApplicationFactory is extension BackupMsSqlDatabaseAsync which creates backup of whole database. To restore state, use RestoreMsSqlDatabasesAsync . Do not use master To make this whole work, ensure that you are not using master as db. This can be achieved by defining database name in UseSql settings as shown bellow: .UseSql(SqlSeed, (configuration, sqlSettings) => { configuration.AddConnectionString(\"Web\", sqlSettings.ConnectionString); }, opts => { opts.Database = \"TestDb\"; //specify name, default is master }) [Fact] public async Task SomeUpdatingOrCreatingtestScenario() { //Create backup await fixture.BackupMsSqlDatabasesAsync(); var res = await fixture.Client.PutAsync(\"sql\", someObject); res.AssertStatusCode(System.Net.HttpStatusCode.OK); //Restore data await fixture.RestoreMsSqlDatabasesAsync(); }","title":"Backup and Restore"},{"location":"sql/extensions/#obtain-data-from-sql-for-futher-use","text":"To Get data there are extension on ITestsFixture and IApplicationFactory named GetMsSqlObjectAsync and GetRawMsSqlObjectAsync or for collection you can use GetMsSqlCollectionAsync","title":"Obtain data from sql for futher use"},{"location":"sql/extensions/#getmssqlobjectasync","text":"This one is trying to map data for you from sql response - for mapping purposes is used JSON, so you should reflect naming etc or use native .NET JSON attributes to achieve so. var obj = await fixture.GetMsSqlObjectAsync<SomeTable, int>(\"SomeTable\", 1, \"Id\"); obj?.SomeString.Should().Be(\"MyString\"); No enumerables Do not try to obtain collection of data with this, since this method contains TOP(1) and even will throw exception if object is assignable to IEnumerable","title":"GetMsSqlObjectAsync"},{"location":"sql/extensions/#getrawmssqlobjectasync","text":"Some error may occure in serialization proces, so there is even GetRawMsSqlObjectAsync which returns raw data Raw string This extension returns response from SQL server running inside container, so it is just string which needs some work, but as was foretold, some problems in serialization may occure, so to not let you without this functionality this one comes to play var data = await fixture.GetRawMsSqlObjectAsync(\"SomeTable\", 1, \"Id\"); Example of string data representation returned from container Id SomeInt SomeString ----------- ----------- ------------------------------ 1 0 kokos (1 rows affected)","title":"GetRawMsSqlObjectAsync"},{"location":"sql/extensions/#getmssqlcollectionasync","text":"This one is trying to map collection of data for you from sql response - for mapping purposes is used JSON, so you should reflect naming etc or use native .NET JSON attributes to achieve so. var collectionOfAll = await fixture.GetMsSqlCollectionAsync<SomeTable>(\"SomeTable\"); collectionOfAll.Should().HaveCount(4);","title":"GetMsSqlCollectionAsync"},{"location":"sql/sql/","text":"MsSQL To use MsSQL use extension method on IApplicationFactoryBuilder named UseSql with string seed and delegate containing ConfigurationBuilder and SqlContainerSettings . This will allow you to run MsSQL in docker, create tables and fill em and register it within your fixture as follows. This extension lives in package: Testing.Sql Prepare your sql seed or just use some sort of migrations in startup var sqlSeed = \"CREATE TABLE etc etc...\"; Use it in registration .UseSql(sqlSeed, (configuration, options) => { configuration.AddConnectionString(\"Web\", options.ConnectionString); })","title":"SQL"},{"location":"sql/sql/#mssql","text":"To use MsSQL use extension method on IApplicationFactoryBuilder named UseSql with string seed and delegate containing ConfigurationBuilder and SqlContainerSettings . This will allow you to run MsSQL in docker, create tables and fill em and register it within your fixture as follows. This extension lives in package: Testing.Sql Prepare your sql seed or just use some sort of migrations in startup var sqlSeed = \"CREATE TABLE etc etc...\"; Use it in registration .UseSql(sqlSeed, (configuration, options) => { configuration.AddConnectionString(\"Web\", options.ConnectionString); })","title":"MsSQL"}]}